import threading  # Import threading for multi-threading functionality
import requests  # Import requests for making HTTP requests
import socket  # Import socket for scanning open ports
import logging  # Import logging for tracking results and errors
from queue import Queue  # Import Queue to manage multi-threaded tasks
from time import time  # Import time for tracking scan duration

# Configure logging to write messages to a file with a specific format
logging.basicConfig(filename="scan_log.txt", level=logging.INFO,
                    format="%(asctime)s:%(levelname)s:%(message)s")

# Function to scan for open ports on a given target
def scan_ports(target):
    open_ports = []  # List to store open ports found during the scan
    for port in range(1, 1025):  # Loop through ports from 1 to 1024
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # Create a new socket object for TCP
        sock.settimeout(1)  # Set a timeout of 1 second for connection attempts
        result = sock.connect_ex((target, port))  # Attempt to connect to the target on the current port
        if result == 0:  # If the result is 0, the port is open
            open_ports.append(port)  # Add the open port to the list
            logging.info(f"Open port found: {port} on {target}")  # Log the open port
        sock.close()  # Close the socket after checking the port
    return open_ports  # Return the list of open ports

# Set up vulnerability scanning rules, which can be customized as needed
vulnerability_rules = {
    "SQLi": ["' OR 1=1 --", "' UNION SELECT"],  # SQL injection payloads
    "XSS": ["<script>alert(1)</script>", "<img src=x onerror=alert(1)>"],  # XSS payloads
    "CSRF": ["csrf_token"]  # CSRF token identifier
}

# Function to check for SQL injection vulnerabilities on a given URLdef scan_sql_injection(url):
def scan_sql_injection(url):
    for payload in vulnerability_rules["SQLi"]:  # Loop through each SQLi payload
        # Append payload as a query parameter
        vulnerable_url = f"{url}?input={payload}"  # Use a sample parameter name (e.g., 'input')
        try:
            response = requests.get(vulnerable_url)  # Send a request with the SQL payload
            # Check if the response contains indications of SQL injection
            if "SQL" in response.text or "syntax error" in response.text:
                logging.warning(f"Possible SQLi vulnerability found at: {url}")  # Log potential SQLi vulnerability
                return True  # Return true if a vulnerability is found
        except Exception as e:  # Handle exceptions that occur during the request
            logging.error(f"Error scanning SQLi on {vulnerable_url}: {str(e)}")  # Log the error
    return False  # Return false if no vulnerabilities are found


# Function to check for XSS vulnerabilities on a given URL
def scan_xss(url):
    for payload in vulnerability_rules["XSS"]:  # Loop through each XSS payload
        try:
            response = requests.get(url, params={"q": payload})  # Send a request with the XSS payload in parameters
            # Check if the XSS payload is reflected in the response
            if payload in response.text:
                logging.warning(f"Possible XSS vulnerability found at: {url}")  # Log potential XSS vulnerability
                return True  # Return true if a vulnerability is found
        except Exception as e:  # Handle exceptions that occur during the request
            logging.error(f"Error scanning XSS on {url}: {str(e)}")  # Log the error
    return False  # Return false if no vulnerabilities are found

# Function to check for CSRF vulnerabilities on a given URL
def scan_csrf(url):
    try:
        response = requests.get(url)  # Get the content of the page
        # Check if the CSRF token is present in the response
        if "csrf_token" not in response.text:
            logging.warning(f"Possible CSRF vulnerability found at: {url}")  # Log potential CSRF vulnerability
            return True  # Return true if a vulnerability is found
    except Exception as e:  # Handle exceptions that occur during the request
        logging.error(f"Error scanning CSRF on {url}: {str(e)}")  # Log the error
    return False  # Return false if no vulnerabilities are found

# Main function to scan a single target for open ports and vulnerabilities
def scan_target(target):
    logging.info(f"Starting scan for {target}")  # Log the start of the scan
    ports = scan_ports(target)  # Call the function to scan for open ports
    for port in ports:  # Loop through each open port found
        logging.info(f"Port {port} is open on {target}")  # Log the open port

    # Prefix the target with 'http://' for vulnerability checks
    url = f"http://{target}"

    # Test for SQL injection vulnerability
    sql_vulnerable = scan_sql_injection(url)
    if sql_vulnerable:
        logging.info(f"SQL Injection found at {target}")  # Log SQL Injection vulnerability

    # Test for XSS vulnerability
    xss_vulnerable = scan_xss(url)
    if xss_vulnerable:
        logging.info(f"XSS vulnerability found at {target}")  # Log XSS vulnerability

    # Test for CSRF vulnerability
    csrf_vulnerable = scan_csrf(url)
    if csrf_vulnerable:
        logging.info(f"CSRF vulnerability found at {target}")  # Log CSRF vulnerability

    logging.info(f"Finished scan for {target}")  # Log the end of the scan

    # If no vulnerabilities were found, log that information
    if not (sql_vulnerable or xss_vulnerable or csrf_vulnerable):
        logging.info(f"No vulnerabilities found on {target}")

# Thread worker function for scanning in parallel
def thread_worker(queue):
    while not queue.empty():  # Continue until the queue is empty
        target = queue.get()  # Get a target from the queue
        scan_target(target)  # Scan the target for vulnerabilities
        queue.task_done()  # Mark the task as done

# Main function to start scanning multiple targets
def start_scan(targets, num_threads=5):
    queue = Queue()  # Initialize a queue for task management
    for target in targets:  # Loop through each target and add to the queue
        queue.put(target)  # Add targets to the queue
    
    # Create threads for multi-threaded scanning
    for _ in range(num_threads):
        thread = threading.Thread(target=thread_worker, args=(queue,))
        thread.start()  # Start each thread for concurrent scanning
    
    queue.join()  # Wait for all tasks in the queue to complete

# Sample usage with multiple targets
if __name__ == "__main__":
    start_time = time()  # Record the start time for the scan
    targets = ["192.168.0.128"]  # List of target IP addresses
    start_scan(targets)  # Start the scanning process
    logging.info(f"Scanning completed in {time() - start_time} seconds")  # Log the total scan duration
